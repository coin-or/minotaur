//
//     MINOTAUR -- It's only 1/2 bull
//
//     (C)opyright 2008 - 2024 The Minotaur Team.
//

/**
 * \file KnapCovHandler.h
 * \brief Declare the KnapCovHandler class for handling knapsack cover 
 * constraints. It generates the cuts whenever they are needed. 
 * \author Serdar Yildiz, Argonne National Laboratory
 */

#include <string>
#include <cmath>

#include "KnapCovHandler.h"  
#include "Constraint.h"
#include "Problem.h"
#include "Node.h"
#include "CoverCutGenerator.h"
#include "CutManager.h"
#include "Option.h"

using namespace Minotaur;

typedef std::vector<ConstraintPtr>::const_iterator CCIter;
//const std::string KnapCovHandler::me_ = "KnapCovHandler: ";

// probably I will disable this function later.
KnapCovHandler::KnapCovHandler()
  : env_(EnvPtr()),
    minlp_(ProblemPtr()),
    stats_(0)
{
  // This is an abstract class, find a way to make this work such as Logger(log1).
  //logger_ = (LoggerPtr) new Logger();
  intTol_ = env_->getOptions()->findDouble("int_tol")->getValue();
  
}

KnapCovHandler::KnapCovHandler(EnvPtr env, ProblemPtr minlp)
  : env_(env),
    minlp_(minlp),
    stats_(0)
{
  intTol_ = env_->getOptions()->findDouble("int_tol")->getValue();
  // Initialize logger.
  // Initialize statistics.
  stats_ = new KCStats();
  stats_->knaps = 0;
  stats_->cuts = 0;
  stats_->extended = 0;
  stats_->simple = 0;
  stats_->gns = 0;
  stats_->singlectwo = 0;
  stats_->time  = 0.0;
  stats_->cutdel = 0;
  
}

KnapCovHandler::~KnapCovHandler()
{
  if (stats_) {
    //writeStats(logger_->MsgStream(LogInfo));
    delete stats_;
  }
  //env_.reset();
  //minlp_.reset();
  
}

bool KnapCovHandler::isFeasible(ConstSolutionPtr , RelaxationPtr ,
				bool &, double &)
{
  // no need to check feasibility of knapsack constraints. It is automatically implied by
  // linear handler and integer handler.
  return true;
}

void KnapCovHandler::separate(ConstSolutionPtr sol, NodePtr,
                              RelaxationPtr rel, CutManager * cmanager,
                              SolutionPoolPtr , ModVector & ,
                              ModVector & , bool * , SeparationStatus * status)
{
  // Check integer feasibility of sol, must add cuts if it is not integral.
  numvars_ = minlp_->getNumVars();
  VariableType type;
  const double * x = sol->getPrimal();
  // Is the relaxation solution is integer feasible.
  bool isintfeas = true;
  // Iterators for variables.
  VariableConstIterator it;
  VariableConstIterator begin = rel->varsBegin();
  VariableConstIterator end   = rel->varsEnd();
  // Temporary variable holder.
  ConstVariablePtr var; 
  // Value of variable.
  double value;
  bool separated = false;
  UInt n_added = 0;

  // Check if integrality is satisfied for each integer variable. 
  for (it=begin; it!=end; ++it) {
    var = *it;
    type = var->getType();
    if (type==Binary || type==Integer) {
      value = x[var->getIndex()];
      if (fabs(value - floor(value + 0.5)) > intTol_) {
        isintfeas = false;
        break;
      }
    }
  }

  if (isintfeas ==  false) {
    // We do another check in CoverCutGneerator for integrality, may be we
    // should eliminate it and use the one above.
    // Generate cover cuts from current relaxation.
    CoverCutGeneratorPtr cover = (CoverCutGeneratorPtr) new CoverCutGenerator(rel,sol, env_);
    // Add cuts to the relaxation by using cut manager.
    CutVector violatedcuts = cover->getViolatedCutList();
    CutIterator itc;
    CutIterator beginc = violatedcuts.begin();
    CutIterator endc   = violatedcuts.end();
    
    // Serdar I am not sure if we should add the constraints generated by
    // addCuts to the constraint vector of knapsack cover handler.
    // Currently CutMan2::addCuts does not add the cuts to the relaxation formulation.
    cmanager->addCuts(beginc, endc);
    cmanager->separate(rel, sol, &separated, &n_added);
    if (n_added>0) {
      *status = SepaResolve;
    }
    
    // Update statistics by using return from cover cut generator.
    ConstCovCutGenStatsPtr covstats = cover->getStats();
    // Later put the code below to updateStats function.
    stats_->knaps += covstats->knaps;
    stats_->cuts += covstats->cuts;
    stats_->extended += covstats->extended;
    stats_->simple += covstats->simple;
    stats_->gns += covstats->gns;
    stats_->singlectwo += covstats->singlectwo;    
  }

  
}

// void KnapCovHandler::updateStats(ConstCovCutGenStatsPtr covstats)
// {
  
// }


std::string KnapCovHandler::getName() const 
{
  
  return "KnapCovHandler (Knapsack Cover)";
}

void KnapCovHandler::writeStats(std::ostream &) const
{
}



// Local Variables: 
// mode: c++ 
// eval: (c-set-style "k&r") 
// eval: (c-set-offset 'innamespace 0) 
// eval: (setq c-basic-offset 2) 
// eval: (setq fill-column 78) 
// eval: (auto-fill-mode 1) 
// eval: (setq column-number-mode 1) 
// eval: (setq indent-tabs-mode nil) 
// End:
