//
//     Minotaur -- It's only 1/2 bull
//
//     (C)opyright 2009 - 2025 The Minotaur Team.
//

/**
 * \file Variable.h
 * \brief Define the Variable class
 * \author Ashutosh Mahajan, Argonne National Laboratory
 *
 * Methods for handling variables in a problem.
 */


#ifndef MINOTAURVARIABLE_H
#define MINOTAURVARIABLE_H

#include <string>

#include "Types.h"

namespace Minotaur {

  /**
   * Variable class contains methods for defining and changing variables of a
   * Problem. A variable has bounds (lb, ub), a type (binary, integer,
   * continuous), a name, and an id which is unique for the variable and is
   * usually generated by the Problem.
   */
  class Variable {
  public:
    /// Following classes can modify a Variable. All modification methods
    /// are private.
    friend class AnalyticalCenter;
    friend class Linearizations;
    friend class QGHandlerAdvance;
    friend class ParQGHandlerAdvance;
    friend class PerspCon;
    friend class Problem;
    friend class TransSep;
    friend class QGHandler;
    friend class OAHandler;
    friend class QuadHandler;
    friend class MultiSolHeur;

    /// Default constructor.
    Variable();

    /// Construct a variable with an id, lb, ub, type and name.
    Variable(UInt id, UInt index, double lb, double ub, VariableType vtype,
             std::string name);

    /// Destroy.
    virtual ~Variable();

    /// Create a copy.
    VariablePtr clone(UInt id) const;

    /// Get the unique id.
    UInt getId() const { return id_; }

    /**
     * Many operations rely on arrays of values. index_ is the index of
     * variable in such arrays. Thus x[index_] will give the
     * value of this variable in an array x, provided x was populated that
     * way (Most engines etc. will populate it on the basis of index_).
     */
    UInt getIndex() const { return index_; }

    /// Get starting or initial value.
    double getInitVal() const { return initVal_; }

    /// Get lowerbound.
    double getLb() const { return lb_; }

    /// Get upperbound.
    double getUb() const { return ub_; }

    /// Get the type (binary, integer, continuous).
    VariableType getType() const { return vtype_; }

    /// Get the function type of constraints that this variable is in.
    FunctionType getFunType() const { return ftype_; }

    /// Get the type of origin of this variable
    VarSrcType getSrcType() const { return stype_; }

    /// Get the state (fixed, deleted, ...).
    VarState getState() const { return state_; }

    UInt getNumCons() const;

    UInt getItmp() const;

    /// First iterator of constraints where this variable appears.
    ConstrSet::iterator consBegin();

    /// Last iterator of constraints where this variable appears.
    ConstrSet::iterator consEnd();

    /// Get name of the variable.
    const std::string getName() const;

    void setItmp(UInt itmp);

    /**
     * \brief Write the full description of the variable including name,
     * bounds, type etc.
     */
    void write(std::ostream &out) const;

    /// Write the list of constraints in which this variable occurs.
    void writeConstraintMap(std::ostream &out) const;

  protected:
    /// Change the function type to a new value.
    void setFunType_(FunctionType ftype)
    {
      ftype_ = ftype;
      return;
    }

    /// Change the id to a new value.
    void setId_(UInt n) { id_ = n; }

    /// Change the index to a new value.
    void setIndex_(UInt n) { index_ = n; }

    /// Change starting value.
    void setInitVal_(double val) { initVal_ = val; }

    /// Change the lowerbound to a new value.
    void setLb_(double newLb) { lb_ = newLb; }

    /// Change the name to a new value.
    void setName_(std::string newName) { name_ = newName; }

    /// Change the type of the origin of this variable
    void setSrcType(VarSrcType stype) { stype_ = stype; }

    /// Change the state to a new value.
    void setState_(VarState state)
    {
      state_ = state;
      return;
    }

    /// Change the type to a new value.
    void setType_(VariableType vtype);

    /// Change the upperbound to a new value.
    void setUb_(double newUb) { ub_ = newUb; }

    /**
     * \brief Remove the constraint from the list of constraints this variable
     * belongs to.
     */
    void outOfConstraint_(ConstraintPtr cPtr);

    /**
     * \brief Add the constraint to the list of constraints this variable
     * belongs to.
     */
    void inConstraint_(ConstraintPtr c);

    /// Clear the list of constraints this variable belongs to.
    void clearConstraints_();

  private:
    /// Set of constraints in which this variable appears.
    ConstrSet cons_;

    /// What kind of constraints does it appear in? Linear, Quadratic, ...
    FunctionType ftype_;

    /// unique id for this variable
    UInt id_;

    /// index for this variable
    UInt index_;

    /// lower bound
    double lb_;

    /// name
    std::string name_;

    /// Starting or initial value, sometimes used by NLP engines or heuristics
    double initVal_;

    /// state: fixed, freed etc
    VarState state_;

    /// Where did this variable originate? Original problem, transformer, etc.
    VarSrcType stype_;

    /// upper bound
    double ub_;

    /// type: integer, binary, continuous etc
    VariableType vtype_;

    /// Copy constructor is not allowed.
    Variable(const Variable &v);

    /// Copy by assignment is no allowed.
    Variable &operator=(const Variable &v);

    /// Temporary integer variable.
    UInt itmp_;
  };

  typedef std::set<std::pair<ConstraintPtr, FunctionType>>::const_iterator
      ConstraintFunIterator;
}  //namespace Minotaur

#endif
