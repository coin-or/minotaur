//
//     Minotaur -- It's only 1/2 bull
//
//     (C)opyright 2008 - 2025 The Minotaur Team.
//

/**
 * \file KnapCovHandler.h
 * \brief Declare the KnapCovHandler class for handling knapsack cover
 * constraints. It generates the cuts whenever they are needed.
 * \author Serdar Yildiz, Argonne National Laboratory
 */

#ifndef MINOTAURKNAPCOVHANDLER_H
#define MINOTAURKNAPCOVHANDLER_H

#include "Handler.h"
#include "Types.h"
#include "Solution.h"
#include "Variable.h"
#include "Relaxation.h"
#include "CoverCutGenerator.h"

namespace Minotaur {

  // Pointers for knapsack cover cut handler are defined.
  class KnapCovHandler;
  typedef KnapCovHandler *KnapCovHandlerPtr;
  typedef const KnapCovHandler *ConstKnapCovHandler;

  class Logger;


  struct KCStats
  {
    UInt knaps;     /// Number of knapsacks solved.
    UInt cuts;      /// Number of cover cuts generated.
    UInt extended;  /// Number of extended cover cuts generated.
    UInt simple;    /// Number of simple lifted cuts generated.
    UInt gns;       /// Number of Gu, Nemhauser, Savelsbergh lifted cover cuts
                    /// generated.
    UInt singlectwo;  /// Number of general lifted cover cuts generated by
                      /// using a single element for C2 (downlifting).
    double time;  /// Total time used to generate cuts.
    UInt cutdel;  /// Number of cuts marked for deletion.
  };

  /**
   * KnapCovHandler class considers knapsack cover cuts in the problem. It
   * generates the cuts and manages them.
   */
  class KnapCovHandler : public Handler {
  public:
    /// Default constructor.
    KnapCovHandler();

    /// Constructor.
    KnapCovHandler(EnvPtr env, ProblemPtr problem);

    /// Destroy
    ~KnapCovHandler();

    /// Does nothing.
    void relaxInitFull(RelaxationPtr, SolutionPool *, bool *) {};

    /// Does nothing.
    void relaxInitInc(RelaxationPtr, SolutionPool *, bool *) {};

    /// Does nothing.
    void relaxNodeFull(NodePtr, RelaxationPtr, bool *) {};

    /// Does nothing.
    void relaxNodeInc(NodePtr, RelaxationPtr, bool *) {};

    /// Check if solution is feasible.
    /// Checks all the constraints if they are satisfied by the given
    /// solution.
    bool isFeasible(ConstSolutionPtr sol, RelaxationPtr relaxation,
                    bool &should_prune, double &inf_meas);


    /**
     * We need separation for this handler to generate the knapsack cover
     * cuts.
     * A set of knapsack cover cuts will be generated.
     */
    void separate(ConstSolutionPtr, NodePtr, RelaxationPtr,
                  CutManager *cutman, SolutionPoolPtr, ModVector &p_mods,
                  ModVector &r_mods, bool *, SeparationStatus *status);

    /// Does nothing.
    virtual void getBranchingCandidates(RelaxationPtr, const DoubleVector &,
                                        ModVector &, BrVarCandSet &,
                                        BrCandVector &, bool &) {};

    /// Does nothing.
    virtual ModificationPtr getBrMod(BrCandPtr, DoubleVector &, RelaxationPtr,
                                     BranchDirection)
    {
      return ModificationPtr();
    };

    /// Does nothing.
    virtual Branches getBranches(BrCandPtr, DoubleVector &, RelaxationPtr,
                                 SolutionPoolPtr)
    {
      return Branches();
    };

    /// Does nothing.
    SolveStatus presolve(PreModQ *, bool *, Solution **) { return Finished; };

    /// Does nothing.
    //void postsolveGetX(const double *, UInt, DoubleVector *) {};

    // Does nothing.
    virtual bool presolveNode(RelaxationPtr, NodePtr, SolutionPoolPtr,
                              ModVector &, ModVector &)
    {
      return false;
    };

    // Write name.
    std::string getName() const;

    /// Show statistics.
    void writeStats(std::ostream &) const;

    /// Updates the handler statistics by using returned information form
    /// cover cut generator.
    // void updateStats(ConsCovCutGenStatsPtr covstats);

    // Return specific statistics.
    UInt KC_knaps() { return stats_->knaps; }
    UInt KC_cuts() { return stats_->cuts; }
    UInt KC_extended() { return stats_->extended; }
    UInt KC_simple() { return stats_->simple; }
    UInt KC_gns() { return stats_->gns; }
    UInt KC_singlectwo() { return stats_->singlectwo; }
    double KC_time() { return stats_->time; }

  private:
    /// Environment.
    EnvPtr env_;

    /// The problem for which the handler is created.
    ProblemPtr minlp_;

    /// Log.
    LoggerPtr logger_;

    /// Statistics.
    KCStats *stats_;

    // Number of variables in the MINLP.
    size_t numvars_;

    /// Tolerance for checking integrality.
    double intTol_;

    /// For log:
    static const std::string me_;
  };
}  //namespace Minotaur


#endif  // MINOTAURKNAPCOVHANDLER_H
